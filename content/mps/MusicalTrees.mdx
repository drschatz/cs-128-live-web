---
title: "Musical Trees"
description: "This article displays the requirements for the Musical Trees MP."
author:
  - "Prof. Schatz"
publishedAt: "2024-10-31"
updatedAt: "2024-10-31"
isPublished: true
tags:
  - "C++"
chapterTitle: "MPs"
chapterIdx: 3
sectionIdx: 3
---

## Important Dates
Part 1 Due Date: Thursday XX at 11:59pm (10 points) (10% point reduction if submitted within 24 hours late)  

[Autograder Part 1](#)  

Part 2 Due Date: Thursday XX at 11:59pm (90 points) (10% point reduction if submitted within 24 hours late)  

[Autograder Part 2](#)

## Introduction

In this MP, you will create a program that generates musical melodies using a tree structure and a genetic algorithm. You do not need to have a background in music to successfully complete this project. These specifications will provide all the background you will need.

## Learning goals

- Use object-oriented design to appropriately structure data and couple data and behavior.
- Formulate and implement useful algorithms that solve problems and can be implemented and run on a computer.
- Construct and test code from a simple specification.

## Topics Covered

Linked data structures (trees), recursion, classes, and dynamic memory.

## Background Information

**Pitch**: How low or high a note sounds.  
**Motif**: A musical fragment. In our case, a series of 6 notes, where each note has a pitch (0 - 127) and duration (0.1 - 0.7 seconds).  
**Melody**: A combination of musical fragments. In our case, 2 or less motifs.

**Genetic Algorithm**: A computational algorithm that is based on the ideas of natural selection. The algorithm runs for many iterations, called generations. In each generation, the following happens:

1. **Selection**: Items are selected based on a fitness score. Items with a higher fitness score are more likely to be chosen.
2. **Reproduction**: Selected items reproduce, creating new items. The new items are based off of their parent but with mutations or other variation.
3. **Pruning**: Items with a low fitness score are removed.

When run for many generations, the end result should be new items with high fitness scores.

## Overview

In this MP, you will implement a tree where each node in the tree holds a motif, a list of children, and a pointer to its parent. The tree will start with just a root node, whose motif forms the starting melody. The genetic algorithm will generate new nodes and prune others. After many iterations of this process, there will be 1-3 motifs left, which will make up the end melody that hopefully sounds more melodic than the starting one!

## Recommended Steps

1. Read through all of the specifications.
2. Get the starter code and read through each file.
3. Work on Part 1 (Due Thursday the XX at 11:59pm).
4. Work on Part 2 (Due Thursday the XX at 11:59pm).

**Note**: This MP is significantly more work per day than the Seam Carver MP2.

## Part 1

In Part 1, you will be implementing the `MotifNode` class that will be used as the nodes for the tree in Part 2.

A `MotifNode` holds a motif (vector of notes), a vector of pointers to its children `MotifNodes`, and a pointer to its parent `MotifNode`. 
Fill in the member functions in `motif_node.cc` as they are specified in `motif_node.hpp`. Make sure the invariant below is true at the 
end of every member function. Note, you can use `this` to access your own address inside of a member function.

### MotifNode Invariant

- Every one of `MotifNode`'s children should have their parent pointer point to this `MotifNode`.


Do not change the interface, i.e., the function signatures of any public member functions for `MotifNode`. 
The autograder assumes the interface of the starter code. However, feel free to add any additional private helper 
member functions. Additionally, do not make any member variables public, as that will introduce potential errors in Part 2.

####Image of 3 connected MotifNodes. 
![enter image description here](https://www.cs128live.org/MotifNodeExample.png)


## Part 2

In Part 2, you will be implementing the `MusicalTree` class. This class is used to create and maintain a tree of `MotifNodes` through the genetic algorithm. This part is more involved than Part 1 and will most likely take significantly more time. Please plan accordingly!

A `MusicalTree` maintains `MotifNodes` on the heap. It only keeps track of the root of the tree and the current size (number of `MotifNodes`).

In order to grade your work, please follow the directions in the specifications and in the starter files exactly. Once you have completed the graded version of the project, feel free to adjust parameters and see if you can create an even better melody!

### MusicalTree Invariants

- There is always a valid root node. Aka, the size should never be less than 1.
- The root node's parent pointer is equal to `nullptr`.
- If a node has children, each of those children are valid `MotifNodes` on the heap (not deleted). Each of the children has a parent pointer pointing back up to the `MotifNode` that holds it.
- Every node, except the root, has exactly 1 parent and is inside of the `children` vector of that parent.
- The size of the tree is the number of valid `MotifNodes` connected through the root.

When debugging, I recommend writing and calling a function to check the invariants at the end of every member function. This will alert you to bugs immediately. For example, breaking an invariant in function A may not cause the program to break until function B is called, making it a challenge to figure out where the bug is. 

For running the final product, please comment out the function calls to the invariant checks, as they do significantly slow down the algorithm.

## Genetic Algorithm Details

### Selection Phase

Traverse every node in the tree and select a subset of nodes based on the following:

- if `RP < SP(node)` --> select node  
  - `RP`: Random probability, a random value between 0 and 1  
  - `SP(node)`: Selection probability of node: `max(fitness score of the node divided by 100, 0.10)`

### Reproduction Phase

Each selected node creates and adds a new child to themselves using the `mutate` function to create the new motif for the child. Each note in the parent's motif is mutated for the child motif by adding a random value between -2 and 2 to the pitch and a random value between -0.1 and 0.1 to the duration. However, the pitch cannot be less than 0 or greater than 127. The duration cannot be less than 0.1 and greater than 0.5. If the new mutated value exceeds these, adjust it to the nearest valid value. For example, if the pitch is mutated to -1, it would be adjusted to 0. Don't forget to update the size in this phase!

### Pruning Phase

This phase removes nodes from the tree that have a motif that evaluates below a threshold in terms of the fitness score. There are a few cases to consider:

- If the node that needs to be pruned is the last node in the tree, do nothing.
- If the node that needs to be pruned has no children, remove it from the tree.
- If the node that needs to be pruned has children, recursively prune all children and their children... etc. Afterward, if the node still has children, rotate up its last child into its place, combining their children.

### Fitness Score

The fitness score is how we will evaluate if a motif sounds melodic or not. We are going to evaluate each motif based on its harmonic and rhythmic qualities. All the music theory research has been done for you! You just need to implement it.

- **Harmonic Score**: A value between 0 and 50 that evaluates the changes in pitch between consecutive notes in a motif. The exact parameters are specified in `musical_trees.hpp` for the `CalculateHarmonicScore` function.
- **Rhythmic Score**: A value between 0 and 50 that evaluates the change in duration between consecutive notes in a motif. The exact parameters are specified in `musical_trees.hpp` for the `CalculateRhythmicScore` function.
- **Pitch Range Penalties**: Penalizes pitches that are too high or too low. The exact parameters are specified in `musical_trees.hpp` for the `FitnessScore` function.

The fitness score is a combination of all these three components. To get the points on the autograder, please follow the exact parameters. On your own, feel free to play around with this part to try and create even better motifs!

## Putting It Together

To start, the code should initialize the starting motif to `{35, 0.1}, {56, 1.0}, {62, 0.2}, {79, 1.0}, {66, 0.1}, {78, 0.8}`.

- To help the tree get going, run the evolve phase 4 times.
- Run the following steps `numGeneration` number of times:
  1. Print out the generation number and the size of the tree.
  2. Run the evolve phase 5 times.
  3. Update the prune threshold as specified in `musical_trees.hpp` for the `DynamicPrune` function.
  4. Prune the tree based on this updated threshold.
- While the size of the tree is greater than 3, add 1 to the prune threshold and prune the tree.
